/*
$Id$
Copyright (C) 2008-2010, The Perl Foundation.

=head1 NAME

src/pmc/perl6multisub.pmc - Perl 6 MultiSub PMC

=head1 DESCRIPTION

Subclass of MultiSub that overrides invoke to implement the Perl 6 multiple
dispatch algorithm, along with providing various other pieces.

Since we need to store some extra information, we cannot just actually be
a ResizablePMCArray, but rather we need to have one.

=head1 INTERNAL STRUCTURES

We have some structures that we use to keep data around internally.

=over 4

=item candidate_info

Represents a candidate. We extract various bits of information about it when
we are building the sorted candidate list and store them in here for fast
access during a dispatch.

*/

#include "parrot/oplib/ops.h"
#include "../binder/bind.h"
#include "pmc_p6lowlevelsig.h"
#include "pmc_sub.h"

PMC *get_all_candidates_with_cur_args(PARROT_INTERP, PMC *multi);

typedef struct candidate_info {
    PMC   *sub;         /* The sub that is the candidate. */
    PMC   *llsig;       /* The signature of the sub. */
    PMC  **types;       /* Class or role type constraints for each parameter. */
    PMC  **constraints; /* Refinement type constraints for each parameter
                         * (if there are many, this will be a junction). */
    INTVAL num_types;   /* Number of entries in the above two arrays. */
    INTVAL min_arity;   /* The number of required positional arguments. */
    INTVAL max_arity;   /* # of required and optional positional arguments. */
    INTVAL bind_check;  /* A true value if any parameters have constraints and/or are named. */
    STRING *req_named;  /* Name of one required named argument, if any. This is to allow us
                         * to quickly rule out candidates disambiguated by a required named
                         * argument, as is the common case for traits. */
} candidate_info;

/*

=item candidate_graph_node

Represents the produced information about a candidate as well as the graph
edges originating from it. The edges array contains pointers to the edges
in the graph that we have arrows to.

*/

typedef struct candidate_graph_node {
    candidate_info               *info;
    struct candidate_graph_node **edges;
    INTVAL                        edges_in;
    INTVAL                        edges_out;
} candidate_graph_node;


/* Some constants for candidate sorter. */
#define EDGE_REMOVAL_TODO -1
#define EDGE_REMOVED      -2

/* Some constants for the dispatcher. */
#define MMD_ONE_RESULT   0
#define MMD_MANY_RESULTS 1

/* Special value we set arity to when we have a slurpy. */
#define SLURPY_ARITY     1 << 30

/*

=back

=head1 FUNCTIONS

These are worker functions used by the methods of the PMC, and not visible
from the outside.

=over 4

=item C<static PMC *get_args(PARROT_INTERP)>

Gets and returns the currnet capture holding the arguments we're being
called with.

=cut

*/

static PMC *
get_args(PARROT_INTERP)
{
    PMC *ctx = CURRENT_CONTEXT(interp);
    PMC *sig = Parrot_pcc_get_signature(interp, ctx);
    return sig;
}


/*

=item C<static INTVAL is_narrower(PARROT_INTERP, candidate_info *a, candidate_info *b)>

Takes two candidates and determines if the first one is narrower than the
second. Returns a true value if they are.

=cut

*/
static INTVAL is_narrower(PARROT_INTERP, candidate_info *a, candidate_info *b) {
    STRING * const ACCEPTS = CONST_STRING(interp, "ACCEPTS");
    INTVAL narrower = 0;
    INTVAL tied = 0;
    INTVAL i, types_to_check;

    /* Work out how many parameters to compare, factoring in slurpiness
     * and optionals. */
    if (a->num_types == b->num_types)
        types_to_check = a->num_types;
    else if (a->min_arity == b->min_arity)
        types_to_check = a->num_types > b->num_types ? b->num_types : a->num_types;
    else
        return 0;

    /* Analyse each parameter in the two candidates. */
    for (i = 0; i < types_to_check; i++) {
        PMC * const type_obj_a = a->types[i];
        PMC * const type_obj_b = b->types[i];
        if (type_obj_a == type_obj_b) {
            /* Same type; narrower if first has constraints and other doesn't;
             * tied if neither has constraints or both have constraints. */
            if (!PMC_IS_NULL(a->constraints[i]) && PMC_IS_NULL(b->constraints[i]))
                narrower++;
            else if ((PMC_IS_NULL(a->constraints[i]) && PMC_IS_NULL(b->constraints[i]))
                 ||
                    (!PMC_IS_NULL(a->constraints[i]) && !PMC_IS_NULL(b->constraints[i])))
                tied++;
        }
        else {
            PMC * const accepts_meth_a = VTABLE_find_method(interp, type_obj_b, ACCEPTS);
            PMC * result_n             = PMCNULL;
            Parrot_ext_call(interp, accepts_meth_a, "PiP->P", type_obj_b, type_obj_a, &result_n);
            if (VTABLE_get_integer(interp, result_n)) {
                /* Narrower - note it and we're done. */
                narrower++;
            }
            else {
                /* Make sure it's tied, rather than the other way around. */
                PMC * const accepts_meth_b = VTABLE_find_method(interp, type_obj_a, ACCEPTS);
                PMC * result_w             = PMCNULL;
                Parrot_ext_call(interp, accepts_meth_b, "PiP->P", type_obj_a, type_obj_b, &result_w);
                if (!VTABLE_get_integer(interp, result_w))
                    tied++;
            }
        }
    }

    /* If one is narrower than the other from current analysis, we're done. */
    if (narrower >= 1 && narrower + tied == types_to_check)
        return 1;

    /* If they aren't tied, we're also done. */
    else if (tied != types_to_check)
        return 0;

    /* Otherwise, we see if one has a slurpy and the other not. A lack of
     * slurpiness makes the candidate narrower. Otherwise, they're tied. */
    return a->max_arity != SLURPY_ARITY && b->max_arity == SLURPY_ARITY;
}


/*

=item C<static candidate_info** sort_candidates(PMC *candidates)>

Takes a ResizablePMCArray of the candidates, collects information about them
and then does a topological sort of them.

=cut

*/
static candidate_info** sort_candidates(PARROT_INTERP, PMC *candidates, PMC **proto_out) {
    INTVAL i;
    PMC    *found_proto = PMCNULL;
    const char *error = NULL;

    /* Allocate results array (just allocate it for worst case, which
     * is no ties ever, so a null between all of them, and then space
     * for the terminating null. */
    INTVAL num_candidates = VTABLE_elements(interp, candidates);
    candidate_info ** const result = mem_allocate_n_zeroed_typed(
            2 * num_candidates + 1, candidate_info*);

    /* Create a node for each candidate in the graph. */
    candidate_graph_node ** const graph = mem_allocate_n_zeroed_typed(
            num_candidates, candidate_graph_node*);

    INTVAL insert_pos = 0;

    for (i = 0; i < num_candidates; i++) {
        PMC *llsig, *p6_do;
        struct llsig_element **sig_elem_info;
        candidate_info *info;
        INTVAL sig_elems;
        INTVAL j;
        INTVAL significant_param;

        /* Get information about this candidate. */
        PMC * const candidate = VTABLE_get_pmc_keyed_int(interp, candidates, i);
        PMC * const proto     = VTABLE_getprop(interp, candidate, CONST_STRING(interp, "proto"));

        /* Is it a proto? */
        if (!PMC_IS_NULL(proto) && VTABLE_get_bool(interp, proto)) {
            if (PMC_IS_NULL(found_proto))
                found_proto = candidate;
            else
                error = "Can only have one proto in a single scope.";
            continue;
        }

        /* Otherwise, need an entry. */
        info      = mem_allocate_zeroed_typed(candidate_info);
        info->sub = candidate;

        /* Get hold of signature. */
        p6_do = candidate->vtable->base_type == enum_class_Sub ? candidate :
                VTABLE_get_attr_str(interp, candidate, CONST_STRING(interp, "$!do"));
        llsig = VTABLE_getprop(interp, p6_do, CONST_STRING(interp, "$!llsig"));
        if (PMC_IS_NULL(llsig)) {
            /* No signature - need to lazily generate it. */
            PMC *sig_meth    = VTABLE_find_method(interp, p6_do, Parrot_str_new(interp, "!llsig", 0));
            Parrot_ext_call(interp, sig_meth, "P->P", p6_do, &llsig);
        }
        info->llsig = llsig;
        GETATTR_P6LowLevelSig_elements(interp, llsig, sig_elem_info);
        GETATTR_P6LowLevelSig_num_elements(interp, llsig, sig_elems);

        /* Type information. */
        info->types       = mem_allocate_n_zeroed_typed(sig_elems + 1, PMC*);
        info->constraints = mem_allocate_n_zeroed_typed(sig_elems + 1, PMC*);
        significant_param = 0;

        for (j = 0; j < sig_elems; j++) {
            /* If it's named (and not slurpy) don't need its type info but we
             * will need a bindability check during the dispatch for it. */
            if (!PMC_IS_NULL(sig_elem_info[j]->named_names)) {
                if (!(sig_elem_info[j]->flags & SIG_ELEM_IS_OPTIONAL))
                    info->req_named = VTABLE_get_string_keyed_int(interp, sig_elem_info[j]->named_names, 0);
                info->bind_check = 1;
                continue;
            }

            /* If it's got a sub-signature, also need a bind check. */
            if (!PMC_IS_NULL(sig_elem_info[j]->sub_llsig))
                info->bind_check = 1;

            /* If it's named slurpy, we're done. */
            if (sig_elem_info[j]->flags & SIG_ELEM_SLURPY_NAMED)
                break;

            /* Otherwise, positional or slurpy and contributes to arity. */
            if (sig_elem_info[j]->flags & SIG_ELEM_SLURPY_POS) {
                info->max_arity = SLURPY_ARITY;
            }
            else if (sig_elem_info[j]->flags & SIG_ELEM_IS_OPTIONAL) {
                info->max_arity++;
            }
            else {
                info->max_arity++;
                info->min_arity++;
            }

            /* Record type info for this parameter. */
            info->types[significant_param]       = sig_elem_info[j]->nominal_type;
            info->constraints[significant_param] = sig_elem_info[j]->post_constraints;
            if (!PMC_IS_NULL(info->constraints[significant_param]))
                info->bind_check = 1;
            if (sig_elem_info[j]->flags & SIG_ELEM_MULTI_INVOCANT)
                info->num_types++;
            significant_param++;
        }

        /* Add it to graph node, and initialize list of edges. */
        graph[insert_pos]        = mem_allocate_zeroed_typed(candidate_graph_node);
        graph[insert_pos]->info  = info;
        graph[insert_pos]->edges = mem_allocate_n_zeroed_typed(
            num_candidates, candidate_graph_node*);

        insert_pos++;
    }

    /* If we found duplicate protos, don't go any further. */
    if (!error) {
        INTVAL candidates_to_sort;
        INTVAL result_pos;

        /* The actual number of candidates needs to discount any protos. */
        num_candidates = insert_pos;

        /* Now analyze type narrowness of the candidates relative to each other
         * and create the edges. */
        for (i = 0; i < num_candidates; i++) {
            INTVAL j;
            for (j = 0; j < num_candidates; j++) {
                if (i == j)
                    continue;
                if (is_narrower(interp, graph[i]->info, graph[j]->info)) {
                    graph[i]->edges[graph[i]->edges_out] = graph[j];
                    graph[i]->edges_out++;
                    graph[j]->edges_in++;
                }
            }
        }

        /* Perform the topological sort. */
        candidates_to_sort = num_candidates;
        result_pos         = 0;

        while (candidates_to_sort > 0) {
            const INTVAL rem_start_point = result_pos;

            /* Find any nodes that have no incoming edges and add them to
             * results. */
            for (i = 0; i < num_candidates; i++) {
                if (graph[i]->edges_in == 0) {
                    /* Add to results. */
                    result[result_pos] = graph[i]->info;
                    graph[i]->info     = NULL;
                    result_pos++;
                    candidates_to_sort--;
                    graph[i]->edges_in = EDGE_REMOVAL_TODO;
                }
            }
            if (rem_start_point == result_pos) {
                error = "Circularity detected in multi sub types.";
                break;
            }

            /* Now we need to decrement edges in counts for things that had
             * edges from candidates we added here. */
            for (i = 0; i < num_candidates; i++) {
                if (graph[i]->edges_in == EDGE_REMOVAL_TODO) {
                    INTVAL j;
                    for (j = 0; j < graph[i]->edges_out; j++)
                        graph[i]->edges[j]->edges_in--;
                    graph[i]->edges_in = EDGE_REMOVED;
                }
            }

            /* This is end of a tied group, so leave a gap. */
            result_pos++;
        }
    }

    /* Free memory associated with the graph. */
    for (i = 0; i < num_candidates; i++) {
        candidate_info *info = graph[i]->info;
        if (info) {
            if (info->types)
                mem_sys_free(info->types);
            if (info->constraints)
                mem_sys_free(info->constraints);
            mem_sys_free(info);
        }
        mem_sys_free(graph[i]->edges);
        mem_sys_free(graph[i]);
    }

    mem_sys_free(graph);

    /* If we had an error, free memory for result array and throw exception. */
    if (error) {
        mem_sys_free(result);
        Parrot_ex_throw_from_c_args(interp, 0, 1, error);
    }

    *proto_out = found_proto;
    return result;
}


/*

=item C<static INTVAL has_junctional_args(PARROT_INTERP, PMC *args)>

Checks if any of the args are junctional.

=cut

*/

static INTVAL has_junctional_args(PARROT_INTERP, PMC *args) {
    const INTVAL num_args   = VTABLE_elements(interp, args);
    STRING * const junction = CONST_STRING(interp, "Junction");
    INTVAL i;

    for (i = 0; i < num_args; i++) {
        PMC * const arg = VTABLE_get_pmc_keyed_int(interp, args, i);
        if (VTABLE_isa(interp, arg, junction))
            return 1;
    }
    return 0;
}


/*

=item C<static STRING* dump_signature(PARROT_INTERP, STRING *so_far, PMC *sub)>

Utility for getting hold of the signature dump for a sub, which aids us in
producing awesomer errors.

=cut

*/
static STRING* dump_signature(PARROT_INTERP, STRING *so_far, PMC *sub) {
    STRING * const sig_name  = CONST_STRING(interp, "signature");
    STRING * const perl_name = CONST_STRING(interp, "perl");
    STRING * const newline   = CONST_STRING(interp, "\n");
    PMC    * sig_meth, *sig_obj, *perl_meth;
    STRING *sig_perl;
    sig_meth = VTABLE_find_method(interp, sub, sig_name);
    Parrot_ext_call(interp, sig_meth, "Pi->P", sub, &sig_obj);
    perl_meth = VTABLE_find_method(interp, sig_obj, perl_name);
    Parrot_ext_call(interp, perl_meth, "Pi->S", sig_obj, &sig_perl);
    so_far = Parrot_str_concat(interp, so_far, sig_perl);
    so_far = Parrot_str_concat(interp, so_far, newline);
    return so_far;
}


/*

=item C<static PMC* do_dispatch(PARROT_INTERP, PMC *self, candidate_info **candidates,
                                PMC *proto, PMC *capture, int many, int num_candidates,
                                opcode_t *next, MMD_Cache *cache)>

Runs the Perl 6 MMD algorithm. If many is set to a true value, returns a
ResizablePMCArray of all possible candidates, which may be empty. If many
is false, then returns either the one winning unambiguous candidate
or throws an error saying that the dispatch failed if there were no
candidates or that it was ambiguous if there were tied candidates.

=cut

*/

static PMC* do_dispatch(PARROT_INTERP, PMC *self, candidate_info **candidates, PMC *proto,
        PMC *capture, int many, int num_candidates, opcode_t *next,
        MMD_Cache *cache) {
    INTVAL           type_mismatch;
    STRING * const   ACCEPTS          = CONST_STRING(interp, "ACCEPTS");
    INTVAL           possibles_count  = 0;
    const INTVAL     num_args         = VTABLE_elements(interp, capture);
    candidate_info **cur_candidate    = candidates;
    candidate_info **possibles        = mem_allocate_n_typed(num_candidates,
                                         candidate_info *);
    INTVAL           type_check_count;
    PMC             *junctional_res   = PMCNULL;
    INTVAL           pure_type_result = 1;

    /* Iterate over the candidates and collect best ones; terminate
     * when we see two nulls (may break out earlier). */
    while (1) {
        INTVAL i;

        if (*cur_candidate == NULL) {
            /* We've hit the end of a tied group now. If any of them have a
             * bindability check requirement, we'll do any of those now. */
            if (possibles_count) {
                INTVAL bind_check_result = 0;
                candidate_info **new_possibles = NULL;
                INTVAL new_possibles_count = 0;
                INTVAL i;

                for (i = 0; i < possibles_count; i++) {
                    interp->current_cont = NEED_CONTINUATION;
                    Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), NULL);

                    /* First, if there's a required named parameter and it was
                     * not passed, we can very quickly eliminate this candidate
                     * without doing a full bindability check. */
                    if (possibles[i]->req_named) {
                        if (!VTABLE_exists_keyed_str(interp, capture, possibles[i]->req_named)) {
                            /* Required named arg not passed, so we eliminate
                             * it right here. Flag that we've built a list of
                             * new possibles, and that this was not a pure
                             * type-based result that we can cache. */

                            if (!new_possibles)
                                new_possibles = mem_allocate_n_typed(num_candidates, candidate_info *);
                            pure_type_result = 0;
                            continue;
                        }
                    }

                    /* Otherwise, may need full bind check. */
                    if (possibles[i]->bind_check) {
                        /* We'll invoke the sub (but not re-enter the runloop)
                         * and then attempt to bind the signature. */
                        PMC      *invokee   = possibles[i]->sub->vtable->base_type == enum_class_Sub ?
                                possibles[i]->sub : VTABLE_get_attr_str(interp, possibles[i]->sub, CONST_STRING(interp, "$!do"));
                        opcode_t *where     = VTABLE_invoke(interp, invokee, next);
                        PMC      *lexpad    = Parrot_pcc_get_lex_pad(interp, CURRENT_CONTEXT(interp));
                        PMC      *llsig     = possibles[i]->llsig;
                        INTVAL bind_check_result;
                        bind_check_result = Rakudo_binding_bind_llsig(interp, lexpad,
                              llsig, capture, 1, NULL);

                        /* XXX In the future, we can actually keep the context if we only
                         * need one candidate, and then hand back the current PC and mark
                         * the context as not needing a bind. Just needs some code re-org.
                         * For now, we always clean up the ret-cont again. */
                        where = VTABLE_invoke(interp, Parrot_pcc_get_continuation(interp, CURRENT_CONTEXT(interp)), where);

                        /* If we haven't got a possibles storage space, allocate it now. */
                        if (!new_possibles)
                            new_possibles = mem_allocate_n_typed(num_candidates, candidate_info *);

                        /* If we don't fail, need to put this one onto the list
                         * (note that needing a junction dispatch is OK). */
                        if (bind_check_result != BIND_RESULT_FAIL) {
                            new_possibles[new_possibles_count] = possibles[i];
                            new_possibles_count++;
                        }

                        /* Since we had to do a bindability check, this is not
                         * a result we can cache on nominal type. */
                        pure_type_result = 0;
                    }
                }

                /* If we have an updated list of possibles, free old one and use this
                 * new one from here on in. */
                if (new_possibles) {
                    mem_sys_free(possibles);
                    possibles = new_possibles;
                    possibles_count = new_possibles_count;
                }
            }

            /* Now we have eliminated any that fail the bindability check. If
             * we're looking for just one result, we now have it so we can stop. */
            if (many == MMD_ONE_RESULT && possibles_count)
                break;

            /* Otherwise, we keep looping and looking, unless we really hit the end. */
            if (cur_candidate[1]) {
                cur_candidate++;
                continue;
            }
            else {
                break;
            }
        }

        /* Check if it's admissable by arity. */
        if (num_args < (*cur_candidate)->min_arity
        ||  num_args > (*cur_candidate)->max_arity) {
            cur_candidate++;
            continue;
        }

        /* Check if it's admissable by type. */
        type_check_count = (*cur_candidate)->num_types > num_args
                         ? num_args
                         : (*cur_candidate)->num_types;
        type_mismatch = 0;

        for (i = 0; i < type_check_count; i++) {
            PMC * const param        = VTABLE_get_pmc_keyed_int(interp, capture, i);
            PMC * const type_obj     = (*cur_candidate)->types[i];
            PMC * const accepts_meth = VTABLE_find_method(interp, type_obj, ACCEPTS);
            PMC * result             = PMCNULL;
            Parrot_ext_call(interp, accepts_meth, "PiP->P", type_obj, param, &result);
            if (!VTABLE_get_integer(interp, result)) {
                type_mismatch = 1;
                break;
            }
        }

        if (type_mismatch) {
            cur_candidate++;
            continue;
        }

        /* If we get here, it's an admissable candidate; add to list. */
        possibles[possibles_count] = *cur_candidate;
        possibles_count++;
        cur_candidate++;
    }

    /* Check is default trait if we still have multiple options and we want one. */
    if (possibles_count > 1) {
        /* Locate any default candidates; if we find multiple defaults, this is
         * no help, so we'll not bother collection just which ones are good. */
        candidate_info *default_cand = NULL;
        INTVAL i;

        for (i = 0; i < possibles_count; i++) {
            PMC * const default_meth = VTABLE_find_method(interp, possibles[i]->sub,
                    CONST_STRING(interp, "default"));
            if (!PMC_IS_NULL(default_meth)) {
                PMC *result = PMCNULL;;
                Parrot_ext_call(interp, default_meth, "Pi->P", possibles[i]->sub, &result);
                if (VTABLE_get_bool(interp, result)) {
                    if (default_cand == NULL) {
                        default_cand = possibles[i];
                    }
                    else {
                        default_cand = NULL;
                        break;
                    }
                }
            }
        }
        if (default_cand) {
            possibles[0] = default_cand;
            possibles_count = 1;
        }
    }

    /* If we're at a single candidate here, and we are only looking for one, and we
     * also know there's no type constraints that follow, we can cache the result. */
    if (many == MMD_ONE_RESULT && possibles_count == 1 && pure_type_result) {
        if (!cache) {
            cache = Parrot_mmd_cache_create(interp);
            SETATTR_Perl6MultiSub_cache_single(interp, self, cache);
        }
        Parrot_mmd_cache_store_by_values(interp, cache, "", capture, possibles[0]->sub);
    }

    /* Perhaps we found nothing but have junctional arguments? */
    if (possibles_count == 0 && has_junctional_args(interp, capture)) {
        /* Look up multi junction dispatcher, clone it, attach this multi-sub
         * as a property and hand that back as the dispatch result. We also
         * stick it in the MMD cache for next time around. */
        PMC *sub = Parrot_ns_find_namespace_global(interp, Parrot_get_ctx_HLL_namespace(interp),
                CONST_STRING(interp, "!DISPATCH_JUNCTION_MULTI"));
        sub = VTABLE_clone(interp, sub);
        VTABLE_setprop(interp, sub, CONST_STRING(interp, "sub"), self);
        if (cache && many == MMD_ONE_RESULT)
            Parrot_mmd_cache_store_by_values(interp, cache, "", capture, sub);
        junctional_res = sub;
    }

    if (!many) {
        /* Need a unique candidate. */
        if (possibles_count == 1) {
            PMC *result = possibles[0]->sub;
            mem_sys_free(possibles);
            return result;
        }
        else if (!PMC_IS_NULL(junctional_res)) {
            mem_sys_free(possibles);
            return junctional_res;
        }
        else if (!PMC_IS_NULL(proto)) {
            /* If we have a proto at this point, use that. */
            mem_sys_free(possibles);
            return proto;
        }
        else if (possibles_count == 0) {
            /* Get signatures of all possible candidates. We dump them in the
             * order in which we search for them. */
            STRING *signatures = Parrot_str_new(interp, "", 0);
            cur_candidate = candidates;
            while (1) {
                if (!cur_candidate[0] && !cur_candidate[1])
                    break;
                if (cur_candidate[0])
                    signatures = dump_signature(interp, signatures, (*cur_candidate)->sub);
                cur_candidate++;
            }

            mem_sys_free(possibles);
            Parrot_ex_throw_from_c_args(interp, next, 1,
                "No applicable candidates found to dispatch to for '%Ss'. Available candidates are:\n%Ss",
                    VTABLE_get_string(interp, candidates[0]->sub),
                    signatures);
        }
        else {
            /* Get signatures of ambiguous candidates. */
            STRING *signatures = Parrot_str_new(interp, "", 0);
            INTVAL i;
            for (i = 0; i < possibles_count; i++)
                signatures = dump_signature(interp, signatures, possibles[i]->sub);
            
            mem_sys_free(possibles);
            Parrot_ex_throw_from_c_args(interp, next, 1,
                "Ambiguous dispatch to multi '%Ss'. Ambiguous candidates had signatures:\n%Ss",
                    VTABLE_get_string(interp, candidates[0]->sub), signatures);
        }
    }
    else {
        /* Build PMC array of all possibles. */
        PMC * const results = pmc_new(interp, enum_class_ResizablePMCArray);
        INTVAL i;
        for (i = 0; i < possibles_count; i++)
            VTABLE_push_pmc(interp, results, possibles[i]->sub);
        mem_sys_free(possibles);

        /* If nothing was found at all, then supply the proto or junction auto-threader
         * if there is one. */
        if (!PMC_IS_NULL(junctional_res))
            VTABLE_push_pmc(interp, results, junctional_res);
        else if (possibles_count == 0 && !PMC_IS_NULL(proto))
            VTABLE_push_pmc(interp, results, proto);

        /* If we didn't depend upon constraints at all, then we can cache it. */
        if (pure_type_result) {
            if (!cache) {
                cache = Parrot_mmd_cache_create(interp);
                SETATTR_Perl6MultiSub_cache_many(interp, self, cache);
            }
            Parrot_mmd_cache_store_by_values(interp, cache, "", capture, results);
        }

        return results;
    }
}


/*

=item C<static PMC *find_many_candidates_with_arg_list(PARROT_INTERP, PMC *self, PMC *capture)>

Uses the given argument list to find all possible candidates that we could run, sorted
in order of preference.

=cut

*/
static PMC *find_many_candidates_with_arg_list(PARROT_INTERP, PMC *SELF, PMC *capture) {
    candidate_info **candidates = NULL;
    PMC             *unsorted;
    PMC             *proto;
    PMC             *results    = PMCNULL;
    MMD_Cache       *cache;

    /* Need to make sure some bits don't get destroyed. */
    PMC      * ctx               = CURRENT_CONTEXT(interp);
    PMC      * const saved_ccont = interp->current_cont;
    PMC      * const saved_sig   = Parrot_pcc_get_signature(interp, ctx);

    /* See if we have a cache entry. */
    GETATTR_Perl6MultiSub_cache_many(interp, SELF, cache);
    if (cache)
        results = Parrot_mmd_cache_lookup_by_values(interp, cache, "", capture);
    if (PMC_IS_NULL(results)) {
        /* Make sure that we have a candidate list built. */
        GETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
        GETATTR_Perl6MultiSub_candidates(interp, SELF, unsorted);
        GETATTR_Perl6MultiSub_proto(interp, SELF, proto);

        if (!candidates) {
            candidates = sort_candidates(interp, unsorted, &proto);
            SETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
            SETATTR_Perl6MultiSub_proto(interp, SELF, proto);
        }

        if (!candidates)
            Parrot_ex_throw_from_c_args(interp, NULL, 1,
                "Failed to build candidate list");

        /* Now do the dispatch on the args we have been supplied with, and
         * get back a PMC array of possibles. */
        results = do_dispatch(interp, SELF, candidates, proto, capture,
                 MMD_MANY_RESULTS, VTABLE_elements(interp, unsorted), NULL, cache);
    }

    /* Restore stuff that might have got overwritten by calls during the
     * dispatch algorithm. */
    CURRENT_CONTEXT(interp) = ctx;
    interp->current_cont = saved_ccont;
    Parrot_pcc_set_signature(interp, ctx, saved_sig);

    return results;
}



/*

=item C<static int assert_invokable(PARROT_INTERP, PMC *value)>

Checks if a PMC is invokable; returns a true value if so and a false value if
not.

=cut

*/
static int check_invokable(PARROT_INTERP, PMC *value) {
    STRING * const _sub = CONST_STRING(interp, "Sub");
    STRING * const _nci = CONST_STRING(interp, "NCI");
    return VTABLE_isa(interp, value, _sub) || VTABLE_isa(interp, value, _nci);
}

/*

=back

=head1 EXTERNAL FUNCTIONS

=item C<PMC *get_all_candidates_with_cur_args(PARROT_INTERP, PMC *self)>

Uses the arguments currently being passed to find all possible candidates that
we could run, sorted in order of preference. This is made available for calling
by the method dispatcher.

=cut

*/

/* not static; used in P6Invocation PMC */
PMC *get_all_candidates_with_cur_args(PARROT_INTERP, PMC *multi) {
    return find_many_candidates_with_arg_list(interp, multi, get_args(interp));
}

/*

=back

=head1 ATTRIBUTES

=over 4

=item candidates

Unsorted list of all candidates.

=item candidates_sorted

C array of candidate_info structures. It stores a sequence of candidates
length one or greater that are tied, followed by a NULL, followed by the next
bunch that are less narrow but tied and so forth. It is terminated by a double
NULL.

=item cache

A multiple dispatch cache, which memorizes the types we were invoked with so
we can dispatch more quickly.

=item proto

The proto that is in effect.

=back

=head1 METHODS

=over 4

=cut

*/


pmclass Perl6MultiSub extends MultiSub dynpmc group perl6_group manual_attrs {
    ATTR PMC  *candidates;
    ATTR struct candidate_info **candidates_sorted;
    ATTR MMD_Cache *cache_single;
    ATTR MMD_Cache *cache_many;
    ATTR PMC *proto;

/*

=item VTABLE void init()

Allocates the PMC's underlying storage.

=cut

*/
    VTABLE void init() {
        /* Allocate the underlying struct. */
        PMC_data(SELF) = mem_allocate_zeroed_typed(Parrot_Perl6MultiSub_attributes);
        SETATTR_Perl6MultiSub_candidates(interp, SELF, PMCNULL);

        /* Need custom mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);

        /* Set scalar property to avoid. */
        VTABLE_setprop(interp, SELF, CONST_STRING(interp, "scalar"), SELF);
    }

/*

=item VTABLE void destroy()

Frees the memory associated with this PMC's underlying storage.

=cut

*/
    VTABLE void destroy() {
        candidate_info **candidates = NULL;
        MMD_Cache *cache_single;
        MMD_Cache *cache_many;

        /* If we built a sorted candidate list, free that. */
        GETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
        if (candidates) {
            candidate_info **cur_candidate = candidates;
            while (cur_candidate[0] || cur_candidate[1]) {
                if (*cur_candidate) {
                    if ((*cur_candidate)->constraints)
                        mem_sys_free((*cur_candidate)->constraints);
                    if ((*cur_candidate)->types)
                        mem_sys_free((*cur_candidate)->types);
                    mem_sys_free(*cur_candidate);
                }
                cur_candidate++;
            }
            mem_sys_free(candidates);
        }

        /* Free the cache. */
        GETATTR_Perl6MultiSub_cache_single(interp, SELF, cache_single);
        if (cache_single)
            Parrot_mmd_cache_destroy(interp, cache_single);
        GETATTR_Perl6MultiSub_cache_many(interp, SELF, cache_many);
        if (cache_many)
            Parrot_mmd_cache_destroy(interp, cache_many);

        /* Free memory associated with this PMC's underlying struct. */
        mem_sys_free(PMC_data(SELF));
        PMC_data(SELF) = NULL;
    }

    VTABLE PMC* get_pmc_keyed_int(INTVAL value) {
        PMC *candidates;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        return VTABLE_get_pmc_keyed_int(interp, candidates, value);
    }

/*

=item VTABLE opcode_t invoke()

Does a dispatch to the best candidate with the current arguments, according to
the Perl 6 MMD algorithm.

=cut

*/
    VTABLE opcode_t *invoke(void *next) {
        PMC             *found      = PMCNULL;
        MMD_Cache       *cache;
        candidate_info **candidates = NULL;
        PMC             *unsorted;

        /* Need to make sure some stuff doesn't get destroyed. */
        PMC      * ctx               = CURRENT_CONTEXT(interp);
        PMC      * const saved_ccont = interp->current_cont;
        PMC      * const saved_sig   = Parrot_pcc_get_signature(interp, ctx);
        opcode_t * const current_pc  = Parrot_pcc_get_pc(interp, ctx);

        /* Get arguments. */
        PMC *capture = get_args(interp);

        /* See if we have a cache entry. */
        GETATTR_Perl6MultiSub_cache_single(interp, SELF, cache);
        if (cache)
            found = Parrot_mmd_cache_lookup_by_values(interp, cache, "", capture);
        if (PMC_IS_NULL(found)) {
            PMC *proto;

            /* Make sure that we have a candidate list built. */
            GETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
            GETATTR_Perl6MultiSub_candidates(interp, SELF, unsorted);
            GETATTR_Perl6MultiSub_proto(interp, SELF, proto);

            if (!candidates) {
                candidates = sort_candidates(interp, unsorted, &proto);
                SETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
                SETATTR_Perl6MultiSub_proto(interp, SELF, proto);
            }

            if (!candidates)
                Parrot_ex_throw_from_c_args(interp, next, 1,
                    "Failed to build candidate list");

            /* Now do the dispatch on the args we are being invoked with;
             * if it can't find anything, it will throw the required exception. */
            found = do_dispatch(interp, SELF, candidates, proto, capture, MMD_ONE_RESULT,
                    VTABLE_elements(interp, unsorted), (opcode_t *)next, cache);
        }

        /* Restore stuff that might have got overwritten by calls during the
         * dispatch algorithm. */
        CURRENT_CONTEXT(interp) = ctx;
        interp->current_cont = saved_ccont;
        Parrot_pcc_set_signature(interp, ctx, saved_sig);
        Parrot_pcc_set_pc(interp, ctx, current_pc);

        /* Invoke the winner, and mark the context so we know not to re-do a
         * bunch of type checks. */
        next = VTABLE_invoke(interp, found, next);
        PObj_flag_SET(P6S_ALREADY_CHECKED, CURRENT_CONTEXT(interp));
        return (opcode_t *)next;
    }

/*

=item METHOD PMC *find_possible_candidates()

Takes an array of arguments and finds all possible matching candidates.

=cut

*/
    METHOD PMC *find_possible_candidates(PMC *capture) {
        PMC *results = find_many_candidates_with_arg_list(interp, SELF, capture);
        RETURN(PMC *results);
    }

/*

=item C<VTABLE void mark()>

Marks the candidate list.

=cut

*/
    VTABLE void mark() {
        PMC *candidates;
        MMD_Cache *cache_single, *cache_many;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        GETATTR_Perl6MultiSub_cache_single(interp, SELF, cache_single);
        GETATTR_Perl6MultiSub_cache_many(interp, SELF, cache_many);
        if (!PMC_IS_NULL(candidates))
            Parrot_gc_mark_PMC_alive(interp, candidates);
        if (cache_single)
            Parrot_mmd_cache_mark(interp, cache_single);
        if (cache_many)
            Parrot_mmd_cache_mark(interp, cache_many);
    }

/*

=item VTABLE void push_pmc(PMC *sub)

Adds a new candidate to the candidate list.

=cut

*/
    VTABLE void push_pmc(PMC *sub) {
        PMC *candidates;
        MMD_Cache *cache;

        /* Add it to the candidates list. */
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        if (PMC_IS_NULL(candidates)) {
            candidates = pmc_new(interp, enum_class_ResizablePMCArray);
            SETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        }
        VTABLE_push_pmc(interp, candidates, sub);

        /* Invalidate the sorted list - we'll need to re-build it. */
        SETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, NULL);

        /* Invalidate the caches. */
        GETATTR_Perl6MultiSub_cache_single(interp, SELF, cache);
        if (cache)
            Parrot_mmd_cache_destroy(interp, cache);
        cache = NULL;
        SETATTR_Perl6MultiSub_cache_single(interp, SELF, cache);
        GETATTR_Perl6MultiSub_cache_many(interp, SELF, cache);
        if (cache)
            Parrot_mmd_cache_destroy(interp, cache);
        cache = NULL;
        SETATTR_Perl6MultiSub_cache_many(interp, SELF, cache);
    }

/*

=item VTABLE INTVAL elements()

Gets the number of candidate on the candidate list.

=cut

*/
    VTABLE INTVAL elements() {
        PMC *candidates;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        return PMC_IS_NULL(candidates) ? 0 : VTABLE_elements(interp, candidates);
    }

/*

=item VTABLE PMC * get_iter()

Get an iterator over the candidates.

=cut

*/
    VTABLE PMC * get_iter() {
        PMC *candidates;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        return VTABLE_get_iter(interp, candidates);
    }

/*

=item VTABLE PMC * get_pmc_keyed_int()

Gets the candidate at index C<i>.

=cut

*/
    VTABLE PMC * get_pmc_keyed_int(INTVAL i) {
        PMC *candidates, *found;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        found = VTABLE_get_pmc_keyed_int(interp, candidates, i);
        return found->vtable->base_type == enum_class_Sub ? found :
                VTABLE_get_attr_str(interp, found, CONST_STRING(interp, "$!do"));
    }

/*

=item VTABLE PMC * get_pmc_keyed_str()

Converts C<s> to an integer and gets the key at that index.

=cut

*/
    VTABLE PMC * get_pmc_keyed_str(STRING *s) {
        PMC *candidates, *found;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        found = VTABLE_get_pmc_keyed_str(interp, candidates, s);
        return found->vtable->base_type == enum_class_Sub ? found :
                VTABLE_get_attr_str(interp, found, CONST_STRING(interp, "$!do"));
    }

/*

=item VTABLE PMC * get_pmc_keyed()

Converts C<p> to an integer and gets the key at that index.

=cut

*/
    VTABLE PMC * get_pmc_keyed(PMC *p) {
        PMC *candidates, *found;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        found = VTABLE_get_pmc_keyed(interp, candidates, p);
        return found->vtable->base_type == enum_class_Sub ? found :
                VTABLE_get_attr_str(interp, found, CONST_STRING(interp, "$!do"));
    }

/*

=item VTABLE PMC * clone()

Makes a copy of this Perl6MultiSub PMC.

=cut

*/
    VTABLE PMC * clone() {
        PMC * const copy = pmc_new(interp, SELF->vtable->base_type);
        PMC *unsorted;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, unsorted);
        unsorted = VTABLE_clone(interp, unsorted);
        SETATTR_Perl6MultiSub_candidates(interp, copy, unsorted);
        return copy;
    }


/*

=item METHOD PMC * clone()

Makes a copy of this Perl6MultiSub PMC.

=cut

*/
    METHOD PMC * clone() {
        PMC *copy = VTABLE_clone(interp, SELF);
        RETURN (PMC *copy);
    }

/*

=item VTABLE STRING * get_string()

Get an iterator over the candidates.

=cut

*/
    VTABLE STRING * get_string() {
        PMC *candidates;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        if (VTABLE_elements(interp, candidates) > 0)
            return VTABLE_get_string(interp, VTABLE_get_pmc_keyed_int(interp, candidates, 0));
        else
            return CONST_STRING(interp, "<anon>");
    }

/*

=item VTABLE INTVAL * does(STRING *check)

We pretend to do the invokable role, for the benefit of some weird bit of
Parrot that cares.

=cut

*/
    VTABLE INTVAL does(STRING *check) {
        if (Parrot_str_equal(INTERP, check, CONST_STRING(interp, "invokable")))
            return 1;
        else
            return SUPER(check);
    }

/*

=item METHOD void push(candidate)

Adds a candidate.

=cut

*/
    METHOD push(PMC *candidate) {
        VTABLE_push_pmc(interp, SELF, candidate);
        RETURN ()
    }

/*

=item METHOD PMC * candidates()

Gets a list of all candidates.

=cut

*/
    METHOD PMC *ll_candidates() {
        PMC *candidates;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        RETURN (PMC *candidates);
    }

/*

=item METHOD PMC * set_candidates()

Sets the candidate list for this multi, replacing any previous candidate list
that we may have in place. Returns SELF.

=cut

*/
    METHOD PMC *set_candidates(PMC *candidates :slurpy) {
        /* If we already have candidates, add these, otherwise just use them. */
        PMC *existing;
        GETATTR_Perl6MultiSub_candidates(interp, SELF, existing);
        if (PMC_IS_NULL(existing)) {
            SETATTR_Perl6MultiSub_candidates(interp, SELF, candidates);
        }
        else {
            /* If we already have candidates, add these. */
            PMC *iter = VTABLE_get_iter(interp, candidates);
            while (VTABLE_get_bool(interp, iter))
                VTABLE_push_pmc(interp, SELF, VTABLE_shift_pmc(interp, iter));
        }
        RETURN (PMC *SELF);
    }


/*

=item METHOD PMC *incorporate_candidates(PMC *maybe_multi)

Incorporates the given candidates into this multi.

=cut

*/
    METHOD PMC *incorporate_candidates(PMC *maybe_multi) {
        if (!PMC_IS_NULL(maybe_multi) && VTABLE_isa(interp, maybe_multi, CONST_STRING(interp, "Perl6MultiSub"))) {
            INTVAL elements = VTABLE_elements(interp, maybe_multi);
            INTVAL i;
            for (i = 0; i < elements; i++)
                VTABLE_push_pmc(interp, SELF, VTABLE_get_pmc_keyed_int(interp, maybe_multi, i));
        }
        RETURN (PMC *SELF);
    }

/*

=item METHOD PMC *merge_candidates(PMC *maybe_multi)

Merges the candidates from C<maybe_multi> into the invocant,
skipping any candidates with subids already present in the invocant.

=cut

*/

    METHOD PMC *merge_candidates(PMC *maybe_multi) {
        if (!PMC_IS_NULL(maybe_multi) && VTABLE_isa(interp, maybe_multi, CONST_STRING(interp, "Perl6MultiSub"))) {
            STRING *dostr = CONST_STRING(interp, "$!do");
            PMC *hash = pmc_new(interp, enum_class_Hash);
            PMC *iter = VTABLE_get_iter(interp, SELF);
            while (VTABLE_get_bool(interp, iter)) {
                PMC *cand  = VTABLE_shift_pmc(interp, iter);
                PMC *dosub = cand->vtable->base_type == enum_class_Sub 
                             ? cand 
                             : VTABLE_get_attr_str(interp, cand, dostr);
                STRING *subid;
                GETATTR_Sub_subid(interp, dosub, subid);
                if (!subid) continue;
                VTABLE_set_pmc_keyed_str(interp, hash, subid, cand);
            }
            iter = VTABLE_get_iter(interp, maybe_multi);
            while (VTABLE_get_bool(interp, iter)) {
                PMC *cand  = VTABLE_shift_pmc(interp, iter);
                PMC *dosub = cand->vtable->base_type == enum_class_Sub 
                             ? cand 
                             : VTABLE_get_attr_str(interp, cand, dostr);
                STRING *subid;
                GETATTR_Sub_subid(interp, dosub, subid);
                if (!subid) continue;
                if (!PMC_IS_NULL(VTABLE_get_pmc_keyed_str(interp, hash, subid)))
                    continue;
                VTABLE_push_pmc(interp, SELF, cand);
                VTABLE_set_pmc_keyed_str(interp, hash, subid, cand);
            }
        }
        RETURN (PMC *SELF);
    }

/*

=item METHOD STRING *dump_sorted_candidate_signatures()

Dumps a list of candidate signautres, sorted in dispatch order.

=cut

*/

    METHOD STRING *dump_sorted_candidate_signatures() {
        candidate_info **candidates    = NULL;
        candidate_info **cur_candidate = NULL;
        STRING          *signatures    = Parrot_str_new(interp, "", 0);
        PMC             *unsorted;

        /* Make sure that we have a candidate list built. */
        GETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
        GETATTR_Perl6MultiSub_candidates(interp, SELF, unsorted);
        if (!candidates) {
            PMC *proto;
            candidates = sort_candidates(interp, unsorted, &proto);
            SETATTR_Perl6MultiSub_candidates_sorted(interp, SELF, candidates);
            SETATTR_Perl6MultiSub_proto(interp, SELF, proto);
        }
        if (!candidates)
            Parrot_ex_throw_from_c_args(interp, NULL, 1,
                "Failed to build candidate list");

        /* Now go over the candidates and build a result string. */
        cur_candidate = candidates;
        while (1) {
            if (!cur_candidate[0] && !cur_candidate[1])
                break;
            if (cur_candidate[0])
                signatures = dump_signature(interp, signatures, (*cur_candidate)->sub);
            cur_candidate++;
        }

        RETURN (STRING *signatures);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
